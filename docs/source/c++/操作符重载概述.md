
# 操作符重载概述

使用关键字`operator`声明函数，可以指定当应用于类实例时该运算符符号（`operator-symbol`）的含义。可以为运算符设置多个含义（也可以称为`重载`），编译器通过检查操作数的类型来区分运算符的不同含义

## 语法

可以在类内或全局作用域内重定义大多数运算符，运算符重载声明如下：

```
type operator operator-symbol ( parameter-list )
```

重载的运算符被看成函数，比如重载加法运算符，相当于调用函数`operator+`；重载加法赋值运算符，相当于调用函数`operator+=`

可被重定义的运算符列表参考：[Redefinable Operators](https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=vs-2019#redefinable-operators)

不可被重定义的运算符列表参考：[Nonredefinable Operators](https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=vs-2019#nonredefinable-operators)

## 分类

按操作数和作用方式的不同可分类重载运算符如下：

1. 一元运算符（`unary operatiors`）
2. 二元运算符（`binary operations`）
3. 赋值运算符（`assignment`）
4. 函数调用（`function call`）
5. 订阅（`subscripting`）
6. 类成员访问（`class-member access`）
7. 递增和递减（`increment and decrement`）
8. 用户自定义类型转换（`user-defined type conversion`）

## 使用

重载后的运算符函数可以隐式通过运算符号进行调用，也可以显式调用运算符函数进行操作。定义类`Complex`并重载加法运算符

```
struct Complex {
    Complex(double r, double i) : re(r), im(i) {}

    Complex operator+(Complex &other);

    void Display() { cout << re << ", " << im << endl; }

private:
    double re, im;
};

// Operator overloaded using a member function
Complex Complex::operator+(Complex &other) {
    return Complex{re + other.re, im + other.im};
}

int main() {
    Complex a = Complex(1.2, 3.4);
    Complex b = Complex(5.6, 7.8);
    Complex c = Complex(0.0, 0.0);

    // 隐式调用
    Complex d = a + b;
    // 隐式调用
    Complex e = c.operator+(d);
    e.Display();
}
```