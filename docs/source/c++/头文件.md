
# 头文件

参考：[Header files (C++)](https://docs.microsoft.com/en-us/cpp/cpp/header-files-cpp?view=vs-2019)

学习头文件的使用规范

## 为什么要使用头文件

通常将变量、函数、类、结构体的声明放置在头文件（`header file`）中，在源文件中使用`#include`指令插入头文件

有两个作用：

1. 保证所有源文件使用同一个声明
2. 有利于程序管理

## include guard

通常，头文件具有`include guard`或`#pragma once`指令，以确保它们不会多次插入到单个`.cpp`文件中

```
// my_class.h
#pragma once
#ifndef MY_CLASS_H // include guard
#define MY_CLASS_H

namespace N
{
    class my_class
    {
    public:
        void do_something();
    };
}

#endif /* MY_CLASS_H */
```

## 头文件包含内容

头文件和源文件一样，也可以包含定义，但是不推荐使用，因为这会造成同一个名称的多次定义

以下内容是不允许或被认为是非常糟糕的做法：

* 在全局作用域或命名空间进行内置类型定义
* 非内联函数定义
* 非`const`变量定义
* 聚合定义（`aggregate definitions`）
* 未命名的名称空间
* `using`指令

使用`using`指令不一定会导致错误，但可能会导致问题，因为它将命名空间引入直接或间接包含该头文件的每个`.cpp`文件的作用域

## 示例代码

```
#pragma once
#include <vector> // #include directive
#include <string>

namespace N  // namespace declaration
{
    inline namespace P
    {
        //...
    }

    enum class colors : short { red, blue, purple, azure };

    const double PI = 3.14;  // const and constexpr definitions
    constexpr int MeaningOfLife{ 42 };
    constexpr int get_meaning()
    {
        static_assert(MeaningOfLife == 42, "unexpected!"); // static_assert
        return MeaningOfLife;
    }
    using vstr = std::vector<int>;  // type alias
    extern double d; // extern variable

#define LOG   // macro definition

#ifdef LOG   // conditional compilation directive
    void print_to_log();
#endif

    class my_class   // regular class definition,
    {                // but no non-inline function definitions

        friend class other_class;
    public:
        void do_something();   // definition in my_class.cpp
        inline void put_value(int i) { vals.push_back(i); } // inline OK

    private:
        vstr vals;
        int i;
    };

    struct RGB
    {
        short r{ 0 };  // member initialization
        short g{ 0 };
        short b{ 0 };
    };

    template <typename T>  // template definition
    class value_store
    {
    public:
        value_store<T>() = default;
        void write_value(T val)
        {
            //... function definition OK in template
        }
    private:
        std::vector<T> vals;
    };

    template <typename T>  // template declaration
    class value_widget;
}
```