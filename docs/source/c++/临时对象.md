
# 临时对象

参考：

[Temporary Objects](https://docs.microsoft.com/en-us/cpp/cpp/temporary-objects?view=vs-2019)

[c++ 临时变量问题？](https://www.zhihu.com/question/41137408)

临时对象的创建有如下原因：

* 要初始化一个`const`引用，但是其初始化器的类型不同于引用的基础类型
* 存储返回用户定义类型的函数的返回值

    * 只有当程序不会将返回值复制到对象时，才会创建这些临时文件

    ```
    // 函数声明，使用自定义类型作为返回值
    UDT Func1();
    ...
    // 调用该函数，不接受返回值。此时编译器创建一个临时对象来保存返回值
    Func1();
    ``` 

    * 创建临时变量的更常见情况是在表达式的计算过程中，必须调用重载的运算符函数。这些重载的运算符函数返回一个用户定义的类型，该类型通常不会复制到另一个对象

    ```
    class Complex {

    public:
        Complex(int num) : num(num) {}

        Complex operator+(Complex &other) {
            return Complex{this->getNum() + other.getNum()};
        }

        int getNum() {
            return num;
        }

    private:
        int num;
    };

    int main() {
        Complex complex1(1), complex2(2), complex3(3);
        // complex1和complex2的加法结果被存储在一个临时对象tmp中
        // tmp再继续和complex3进行加法计算，将结果复制到result
        Complex result = complex1 + complex2 + complex3;

        cout << result.getNum() << endl;
    }
    ```
* 将强制转换的结果存储到用户定义的类型。当给定类型的对象显式转换为用户定义的类型时，该新对象将被构造为临时对象

* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
临时对象的生存期（`lifetime`）由其创建点和销毁点定义。任何创建多个临时对象的表达式最终都会以创建它们的相反顺序销毁它们。创建点及对应销毁点如下所示：

* 创建点：表达式计算的结果
* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
    * 销毁点：在表达式语句的结尾（即分号处）或控制表达式（`for、if、while、do和switch`语句）的结尾销毁表达式计算结果创建的所有临时变量
* 创建点：初始化`const`引用
* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
* [c++ 临时变量问题？](https://www.zhihu.com/question/41137408)
    * 销毁点：如果初始值设定项不是与要初始化的引用类型相同的`lvalue`，则会创建该引用基础类型的临时对象，并使用初始化表达式初始化。此临时对象在其绑定的引用对象被销毁后立即被销毁